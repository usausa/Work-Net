namespace WorkStringGenerator;

using System.Collections.Immutable;
using System.Text;

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

[Generator]
public sealed class Generator : IIncrementalGenerator
{
    // ------------------------------------------------------------
    // Generator
    // ------------------------------------------------------------

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var classes = context.SyntaxProvider
            .CreateSyntaxProvider(
                static (node, _) => IsTargetSyntax(node),
                static (context, _) => GetTargetSyntax(context))
            .SelectMany(static (x, _) => x is not null ? ImmutableArray.Create(x) : ImmutableArray<ClassDeclarationSyntax>.Empty);
        IncrementalValueProvider<(Compilation, ImmutableArray<ClassDeclarationSyntax>)> compilationAndClasses =
            context.CompilationProvider.Combine(classes.Collect());

        context.RegisterImplementationSourceOutput(
            compilationAndClasses,
            static (spc, source) => Execute(spc, source.Item1, source.Item2));
    }

    private static bool IsTargetSyntax(SyntaxNode node) =>
        node is ClassDeclarationSyntax c && c.AttributeLists.Count > 0;

    private static ClassDeclarationSyntax? GetTargetSyntax(GeneratorSyntaxContext context)
    {
        var classDeclarationSyntax = (ClassDeclarationSyntax)context.Node;
        if (context.SemanticModel.GetDeclaredSymbol(classDeclarationSyntax) is not ITypeSymbol typeSymbol)
        {
            return null;
        }

        var hasAttribute = typeSymbol.GetAttributes()
            .Any(static x => x.AttributeClass!.ToDisplayString() == "WorkStringGenerator.ToStringAttribute" &&
                              x.ConstructorArguments.Length == 0);
        if (!hasAttribute)
        {
            return null;
        }

        return classDeclarationSyntax;
    }

    // ------------------------------------------------------------
    // Builder
    // ------------------------------------------------------------

    private static void Execute(SourceProductionContext context, Compilation compilation, ImmutableArray<ClassDeclarationSyntax> classes)
    {
        var enumerableSymbol = compilation.GetTypeByMetadataName("System.Collections.IEnumerable");

        var buffer = new StringBuilder();

        foreach (var classDeclarationSyntax in classes)
        {
            // Check cancel
            context.CancellationToken.ThrowIfCancellationRequested();

            // Build metadata
            var classSemantic = compilation.GetSemanticModel(classDeclarationSyntax.SyntaxTree);
            var classSymbol = (ITypeSymbol)classSemantic.GetDeclaredSymbol(classDeclarationSyntax)!;

            var ns = classSymbol.ContainingNamespace.IsGlobalNamespace
                ? string.Empty
                : classSymbol.ContainingNamespace.ToDisplayString();
            var className = classDeclarationSyntax.Identifier.Text;

            var properties = new List<IPropertySymbol>();
            var currentSymbol = classSymbol;
            while (currentSymbol != null)
            {
                properties.AddRange(currentSymbol.GetMembers().OfType<IPropertySymbol>());
                currentSymbol = currentSymbol.BaseType;
            }

            // Source
            buffer.AppendLine("// <auto-generated />");
            buffer.AppendLine("#nullable disable");

            // namespace
            if (!String.IsNullOrEmpty(ns))
            {
                buffer.Append("namespace ").Append(ns).AppendLine();
            }

            buffer.AppendLine("{");

            // class
            buffer.Append("    partial ").Append(classSymbol.IsValueType ? "struct " : "class ").Append(className).AppendLine();
            buffer.AppendLine("    {");

            // Method
            buffer.AppendLine("        public override string ToString()");
            buffer.AppendLine("        {");
            buffer.AppendLine("            var handler = new global::System.Runtime.CompilerServices.DefaultInterpolatedStringHandler(0, 0, default, stackalloc char[256]);");
            buffer.AppendLine($"            handler.AppendLiteral(\"{className}\");");
            buffer.AppendLine("            handler.AppendLiteral(\" { \");");

            var firstProperty = true;
            foreach (var property in properties)
            {
                if (firstProperty)
                {
                    firstProperty = false;
                }
                else
                {
                    buffer.AppendLine($"            handler.AppendLiteral(\", \");");
                }

                var literal = property.Name + " = ";
                buffer.AppendLine($"            handler.AppendLiteral(\"{literal}\");");

                if (!property.Type.SpecialType.Equals(SpecialType.System_String) &&
                    property.Type.AllInterfaces.Any(x => SymbolEqualityComparer.Default.Equals(x, enumerableSymbol)))
                {
                    // TODO null
                    buffer.AppendLine($"            if ({property.Name} is not null)");
                    buffer.AppendLine("            {");
                    buffer.AppendLine("                handler.AppendLiteral(\"[\");");
                    buffer.AppendLine($"                handler.AppendLiteral(String.Join(\", \", System.Linq.Enumerable.Select({property.Name}, static x => x.ToString())));");
                    buffer.AppendLine("                handler.AppendLiteral(\"]\");");
                    buffer.AppendLine("            }");
                }
                else
                {
                    if (property.Type.IsReferenceType)
                    {
                        // TODO null
                        buffer.AppendLine($"            if ({property.Name} is not null)");
                        buffer.AppendLine("            {");
                        buffer.AppendLine($"                handler.AppendFormatted({property.Name});");
                        buffer.AppendLine("            }");
                    }
                    else
                    {
                        buffer.AppendLine($"            handler.AppendFormatted({property.Name});");
                    }
                }
            }

            buffer.AppendLine("            handler.AppendLiteral(\" }\");");
            buffer.AppendLine("            return handler.ToStringAndClear();");
            buffer.AppendLine("        }");

            buffer.AppendLine("    }");
            buffer.AppendLine("}");

            // Write
            var source = buffer.ToString();
            var filename = MakeRegistryFilename(buffer, ns, className);
            context.AddSource(filename, SourceText.From(source, Encoding.UTF8));

            buffer.Clear();
        }
    }

    private static string MakeRegistryFilename(StringBuilder buffer, string ns, string className)
    {
        buffer.Clear();

        if (!String.IsNullOrEmpty(ns))
        {
            buffer.Append(ns.Replace('.', '_'));
            buffer.Append('_');
        }

        buffer.Append(className);
        buffer.Append(".g.cs");

        return buffer.ToString();
    }
}
