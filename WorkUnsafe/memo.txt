â– Unsafe

// AsPointer
AsPointer<T>(T)	ãƒãƒãƒ¼ã‚¸ãƒ‰ ãƒã‚¤ãƒ³ã‚¿ãƒ¼ã‚’ã‚¢ãƒ³ãƒãƒãƒ¼ã‚¸ãƒ‰ ãƒã‚¤ãƒ³ã‚¿ãƒ¼ã«å¤‰æ›ã—ã¾ã™ã€‚
    // ldarg.0
    // conv.u
    // ret

// SizeOf
SizeOf<T>()	æŒ‡å®šã—ãŸå‹ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãƒ¼ã®å€¤ã®ã‚µã‚¤ã‚ºã‚’è¿”ã—ã¾ã™ã€‚
    return sizeof(T);

// As
As<T>(Object)	æŒ‡å®šã—ãŸã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’æŒ‡å®šã—ãŸå‹ã«ã‚­ãƒ£ã‚¹ãƒˆã—ã¾ã™ã€‚
As<TFrom,TTo>(TFrom)	æŒ‡å®šã—ãŸãƒãƒãƒ¼ã‚¸ãƒ‰ ãƒã‚¤ãƒ³ã‚¿ãƒ¼ã‚’ã€ å‹ã®å€¤ã¸ã®æ–°ã—ã„ãƒãƒãƒ¼ã‚¸ãƒ‰ ãƒã‚¤ãƒ³ã‚¿ãƒ¼ã¨ã—ã¦å†è§£é‡ˆã—ã¾ã™ TToã€‚
    // ldarg.0
    // ret

// Add
Add<T>(T, Int32)	æŒ‡å®šã•ã‚ŒãŸãƒãƒãƒ¼ã‚¸ãƒ‰ ãƒã‚¤ãƒ³ã‚¿ãƒ¼ã«ã‚ªãƒ•ã‚»ãƒƒãƒˆã‚’è¿½åŠ ã—ã¾ã™ã€‚
    return ref AddByteOffset(ref source, (IntPtr)((nint)elementOffset * (nint)sizeof(T)));
Add<T>(T, IntPtr)	æŒ‡å®šã•ã‚ŒãŸãƒãƒãƒ¼ã‚¸ãƒ‰ ãƒã‚¤ãƒ³ã‚¿ãƒ¼ã«è¦ç´ ã‚ªãƒ•ã‚»ãƒƒãƒˆã‚’è¿½åŠ ã—ã¾ã™ã€‚
    return (byte*)source + (elementOffset * (nint)sizeof(T));
Add<T>(T, UIntPtr)	æŒ‡å®šã•ã‚ŒãŸãƒãƒãƒ¼ã‚¸ãƒ‰ ãƒã‚¤ãƒ³ã‚¿ãƒ¼ã«è¦ç´ ã‚ªãƒ•ã‚»ãƒƒãƒˆã‚’è¿½åŠ ã—ã¾ã™ã€‚
    return ref AddByteOffset(ref source, (nuint)(elementOffset * (nuint)sizeof(T)));
Add<T>(Void*, Int32)	æŒ‡å®šã•ã‚ŒãŸã‚¢ãƒ³ãƒãƒãƒ¼ã‚¸ ãƒã‚¤ãƒ³ã‚¿ãƒ¼ã«è¦ç´ ã‚ªãƒ•ã‚»ãƒƒãƒˆã‚’è¿½åŠ ã—ã¾ã™ã€‚
    return ref AddByteOffset(ref source, (IntPtr)((nint)elementOffset * (nint)sizeof(T)));

// AddByteOffset
AddByteOffset<T>(T, IntPtr)	æŒ‡å®šã•ã‚ŒãŸãƒãƒãƒ¼ã‚¸ãƒ‰ ãƒã‚¤ãƒ³ã‚¿ãƒ¼ã«ãƒã‚¤ãƒˆ ã‚ªãƒ•ã‚»ãƒƒãƒˆã‚’è¿½åŠ ã—ã¾ã™ã€‚
AddByteOffset<T>(T, UIntPtr)	æŒ‡å®šã•ã‚ŒãŸãƒãƒãƒ¼ã‚¸ãƒ‰ ãƒã‚¤ãƒ³ã‚¿ãƒ¼ã«ãƒã‚¤ãƒˆ ã‚ªãƒ•ã‚»ãƒƒãƒˆã‚’è¿½åŠ ã—ã¾ã™ã€‚
    // ldarg .0
    // ldarg .1
    // add
    // ret

// AreSame
AreSame<T>(T, T)	æŒ‡å®šã—ãŸãƒãƒãƒ¼ã‚¸ãƒ‰ ãƒã‚¤ãƒ³ã‚¿ãƒ¼ãŒåŒã˜å ´æ‰€ã‚’æŒ‡ã—ã¦ã„ã‚‹ã‹ã©ã†ã‹ã‚’åˆ¤æ–­ã—ã¾ã™ã€‚

    // ldarg.0
    // ldarg.1
    // ceq
    // ret

// BitCast
BitCast<TFrom,TTo>(TFrom)	å‹ã®æŒ‡å®šã•ã‚ŒãŸå€¤ã‚’ å‹ TFrom ã®å€¤ã¨ã—ã¦å†è§£é‡ˆã—ã¾ã™ TToã€‚
    return ReadUnaligned<TTo>(ref As<TFrom, byte>(ref source));

// Copy
Copy<T>(T, Void*)	æŒ‡å®šã—ãŸå ´æ‰€ã« T å‹ã®å€¤ã‚’ã‚³ãƒ”ãƒ¼ã—ã¾ã™ã€‚
Copy<T>(Void*, T)	æŒ‡å®šã—ãŸå ´æ‰€ã« T å‹ã®å€¤ã‚’ã‚³ãƒ”ãƒ¼ã—ã¾ã™ã€‚
    // ldarg .0
    // ldarg .1
    // ldobj !!T
    // stobj !!T
    // ret


// CopyBlock
CopyBlock(Byte, Byte, UInt32)	ã‚³ãƒ”ãƒ¼å…ƒã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã‹ã‚‰ã‚³ãƒ”ãƒ¼å…ˆã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã«ãƒã‚¤ãƒˆã‚’ã‚³ãƒ”ãƒ¼ã—ã¾ã™ã€‚
CopyBlock(Void*, Void*, UInt32)	ã‚³ãƒ”ãƒ¼å…ƒã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã‹ã‚‰ã‚³ãƒ”ãƒ¼å…ˆã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã«ãƒã‚¤ãƒˆã‚’ã‚³ãƒ”ãƒ¼ã—ã¾ã™ã€‚
    // ldarg .0
    // ldarg .1
    // ldarg .2
    // cpblk
CopyBlockUnaligned(Byte, Byte, UInt32)	ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£ã«ä¾å­˜ã™ã‚‹ã‚¢ãƒ‰ãƒ¬ã‚¹ã®é…ç½®ã‚’è€ƒæ…®ã›ãšã«ã€ã‚³ãƒ”ãƒ¼å…ƒã‚¢ãƒ‰ãƒ¬ã‚¹ã‹ã‚‰ã‚³ãƒ”ãƒ¼å…ˆã‚¢ãƒ‰ãƒ¬ã‚¹ã«ãƒã‚¤ãƒˆã‚’ã‚³ãƒ”ãƒ¼ã—ã¾ã™ã€‚
CopyBlockUnaligned(Void*, Void*, UInt32)	ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£ã«ä¾å­˜ã™ã‚‹ã‚¢ãƒ‰ãƒ¬ã‚¹ã®é…ç½®ã‚’è€ƒæ…®ã›ãšã«ã€ã‚³ãƒ”ãƒ¼å…ƒã‚¢ãƒ‰ãƒ¬ã‚¹ã‹ã‚‰ã‚³ãƒ”ãƒ¼å…ˆã‚¢ãƒ‰ãƒ¬ã‚¹ã«ãƒã‚¤ãƒˆã‚’ã‚³ãƒ”ãƒ¼ã—ã¾ã™ã€‚
    // ret
    // ldarg .0
    // ldarg .1
    // ldarg .2
    // unaligned. 0x1
    // cpblk
    // ret

// IsAddress
IsAddressGreaterThan<T>(T, T)	æŒ‡å®šã—ãŸãƒãƒãƒ¼ã‚¸ãƒ‰ ãƒã‚¤ãƒ³ã‚¿ãƒ¼ãŒã€æŒ‡å®šã—ãŸåˆ¥ã®ãƒãƒãƒ¼ã‚¸ãƒ‰ ãƒã‚¤ãƒ³ã‚¿ãƒ¼ã‚ˆã‚Šå¤§ãã„ã‹ã©ã†ã‹ã‚’ç¤ºã™å€¤ã‚’è¿”ã—ã¾ã™ã€‚
    // ldarg.0
    // ldarg.1
    // cgt.un
    // ret
IsAddressLessThan<T>(T, T)	æŒ‡å®šã—ãŸãƒãƒãƒ¼ã‚¸ãƒ‰ ãƒã‚¤ãƒ³ã‚¿ãƒ¼ãŒã€æŒ‡å®šã—ãŸåˆ¥ã®ãƒãƒãƒ¼ã‚¸ãƒ‰ ãƒã‚¤ãƒ³ã‚¿ãƒ¼ã‚ˆã‚Šå°ã•ã„ã‹ã©ã†ã‹ã‚’ç¤ºã™å€¤ã‚’è¿”ã—ã¾ã™ã€‚
    // ldarg.0
    // ldarg.1
    // clt.un
    // ret

// InitBlock
InitBlock(Byte, Byte, UInt32)	æŒ‡å®šã—ãŸå ´æ‰€ã®ãƒ¡ãƒ¢ãƒª ãƒ–ãƒ­ãƒƒã‚¯ã‚’æŒ‡å®šã—ãŸåˆæœŸå€¤ã§åˆæœŸåŒ–ã—ã¾ã™ã€‚
InitBlock(Void*, Byte, UInt32)	æŒ‡å®šã—ãŸå ´æ‰€ã®ãƒ¡ãƒ¢ãƒª ãƒ–ãƒ­ãƒƒã‚¯ã‚’æŒ‡å®šã—ãŸåˆæœŸå€¤ã§åˆæœŸåŒ–ã—ã¾ã™ã€‚
    // ldarg .0
    // ldarg .1
    // ldarg .2
    // initblk
    // ret
InitBlockUnaligned(Byte, Byte, UInt32)	ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£ã«ä¾å­˜ã™ã‚‹ã‚¢ãƒ‰ãƒ¬ã‚¹ã®é…ç½®ã‚’è€ƒæ…®ã›ãšã«ã€æŒ‡å®šã—ãŸå ´æ‰€ã®ãƒ¡ãƒ¢ãƒª ãƒ–ãƒ­ãƒƒã‚¯ã‚’æŒ‡å®šã—ãŸåˆæœŸå€¤ã§åˆæœŸåŒ–ã—ã¾ã™ã€‚
InitBlockUnaligned(Void*, Byte, UInt32)	ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£ã«ä¾å­˜ã™ã‚‹ã‚¢ãƒ‰ãƒ¬ã‚¹ã®é…ç½®ã‚’è€ƒæ…®ã›ãšã«ã€æŒ‡å®šã—ãŸå ´æ‰€ã®ãƒ¡ãƒ¢ãƒª ãƒ–ãƒ­ãƒƒã‚¯ã‚’æŒ‡å®šã—ãŸåˆæœŸå€¤ã§åˆæœŸåŒ–ã—ã¾ã™ã€‚
    // ldarg .0
    // ldarg .1
    // ldarg .2
    // unaligned. 0x1
    // initblk
    // ret

// Read
Read<T>(Void*)	æŒ‡å®šã—ãŸå ´æ‰€ã‹ã‚‰ T å‹ã®å€¤ã‚’èª­ã¿å–ã‚Šã¾ã™ã€‚
    return *(T*)source;
ReadUnaligned<T>(Byte)	ã‚½ãƒ¼ã‚¹ ã‚¢ãƒ‰ãƒ¬ã‚¹ã®ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£ã«ä¾å­˜ã™ã‚‹é…ç½®ã‚’æƒ³å®šã›ãšã«ã€æŒ‡å®šã•ã‚ŒãŸã‚¢ãƒ‰ãƒ¬ã‚¹ã‹ã‚‰å‹ T ã®å€¤ã‚’èª­ã¿å–ã‚Šã¾ã™ã€‚
ReadUnaligned<T>(Void*)	ã‚½ãƒ¼ã‚¹ ã‚¢ãƒ‰ãƒ¬ã‚¹ã®ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£ã«ä¾å­˜ã™ã‚‹é…ç½®ã‚’æƒ³å®šã›ãšã«ã€æŒ‡å®šã•ã‚ŒãŸå ´æ‰€ã‹ã‚‰å‹ T ã®å€¤ã‚’èª­ã¿å–ã‚Šã¾ã™ã€‚
    return As<byte, T>(ref Unsafe.AsRef(in source));

// Write
Write<T>(Void*, T)	æŒ‡å®šã—ãŸå ´æ‰€ã« T å‹ã®å€¤ã‚’æ›¸ãè¾¼ã¿ã¾ã™ã€‚
    *(T*)destination = value;
WriteUnaligned<T>(Byte, T)	å®›å…ˆã‚¢ãƒ‰ãƒ¬ã‚¹ã®ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£ã«ä¾å­˜ã™ã‚‹é…ç½®ã‚’æƒ³å®šã›ãšã«ã€æŒ‡å®šã•ã‚ŒãŸå ´æ‰€ã«å‹ T ã®å€¤ã‚’æ›¸ãè¾¼ã¿ã¾ã™ã€‚
WriteUnaligned<T>(Void*, T)	å®›å…ˆã‚¢ãƒ‰ãƒ¬ã‚¹ã®ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£ã«ä¾å­˜ã™ã‚‹é…ç½®ã‚’æƒ³å®šã›ãšã«ã€æŒ‡å®šã•ã‚ŒãŸå ´æ‰€ã«å‹ T ã®å€¤ã‚’æ›¸ãè¾¼ã¿ã¾ã™ã€‚
    As<byte, T>(ref destination) = value;

// AsRef
AsRef<T>(T)	æŒ‡å®šã•ã‚ŒãŸèª­ã¿å–ã‚Šå°‚ç”¨å‚ç…§ã‚’å¤‰æ›´å¯èƒ½ãªå‚ç…§ã¨ã—ã¦å†è§£é‡ˆã—ã¾ã™ã€‚
    return ref *(T*)source;
AsRef<T>(Void*)	ã‚¢ãƒ³ãƒãƒãƒ¼ã‚¸ ãƒã‚¤ãƒ³ã‚¿ãƒ¼ã‚’ å‹ã®å€¤ã«ãƒãƒãƒ¼ã‚¸ãƒ‰ ãƒã‚¤ãƒ³ã‚¿ãƒ¼ã«å¤‰æ›ã—ã¾ã™ Tã€‚
    //ldarg .0
    //ret

// ByteOffset
ByteOffset<T>([AllowNull] ref readonly T origin, [AllowNull] ref readonly T target)
    // ldarg .1
    // ldarg .0
    // sub
    // ret

// NullRef
NullRef<T>()	å‹ã®å€¤ã¸ã® null ãƒãƒãƒ¼ã‚¸ãƒ‰ ãƒã‚¤ãƒ³ã‚¿ãƒ¼ã‚’è¿”ã—ã¾ã™ Tã€‚
    return ref AsRef<T>(null);
    // ldc.i4.0
    // conv.u
    // ret

// IsNullRef
IsNullRef<T>(T)	å‹ T ã®å€¤ã¸ã®ç‰¹å®šã®ãƒãƒãƒ¼ã‚¸ãƒ‰ ãƒã‚¤ãƒ³ã‚¿ãƒ¼ãŒ null å‚ç…§ã§ã‚ã‚‹ã‹ã©ã†ã‹ã‚’åˆ¤æ–­ã—ã¾ã™ã€‚
    return AsPointer(ref Unsafe.AsRef(in source)) == null;
    // ldarg.0
    // ldc.i4.0
    // conv.u
    // ceq
    // ret

// SkipInit
SkipInit<T>(T)	æŒ‡å®šã•ã‚ŒãŸå‚ç…§ã®æ˜ç¢ºãªå‰²ã‚Šå½“ã¦ãƒ«ãƒ¼ãƒ«ã‚’ãƒã‚¤ãƒ‘ã‚¹ã—ã¾ã™ã€‚
    // ret

// Subtract
Subtract<T>(T, Int32)	æŒ‡å®šã•ã‚ŒãŸãƒãƒãƒ¼ã‚¸ãƒ‰ ãƒã‚¤ãƒ³ã‚¿ãƒ¼ã‹ã‚‰ã‚ªãƒ•ã‚»ãƒƒãƒˆã‚’æ¸›ç®—ã—ã¾ã™ã€‚
    return ref SubtractByteOffset(ref source, (IntPtr)(elementOffset * (nint)sizeof(T)));
Subtract<T>(T, IntPtr)	æŒ‡å®šã•ã‚ŒãŸãƒãƒãƒ¼ã‚¸ãƒ‰ ãƒã‚¤ãƒ³ã‚¿ãƒ¼ã‹ã‚‰è¦ç´ ã‚ªãƒ•ã‚»ãƒƒãƒˆã‚’æ¸›ç®—ã—ã¾ã™ã€‚
    return (byte*)source - (elementOffset * (nint)sizeof(T));
Subtract<T>(T, UIntPtr)	æŒ‡å®šã•ã‚ŒãŸãƒãƒãƒ¼ã‚¸ãƒ‰ ãƒã‚¤ãƒ³ã‚¿ãƒ¼ã‹ã‚‰è¦ç´ ã‚ªãƒ•ã‚»ãƒƒãƒˆã‚’æ¸›ç®—ã—ã¾ã™ã€‚
    return ref SubtractByteOffset(ref source, (IntPtr)((nint)elementOffset * (nint)sizeof(T)));
Subtract<T>(Void*, Int32)	æŒ‡å®šã•ã‚ŒãŸã‚¢ãƒ³ãƒãƒãƒ¼ã‚¸ ãƒã‚¤ãƒ³ã‚¿ãƒ¼ã‹ã‚‰è¦ç´ ã‚ªãƒ•ã‚»ãƒƒãƒˆã‚’æ¸›ç®—ã—ã¾ã™ã€‚
    return ref SubtractByteOffset(ref source, (nuint)(elementOffset * (nuint)sizeof(T)));
SubtractByteOffset<T>(T, IntPtr)	æŒ‡å®šã•ã‚ŒãŸãƒãƒãƒ¼ã‚¸ãƒ‰ ãƒã‚¤ãƒ³ã‚¿ãƒ¼ã‹ã‚‰ãƒã‚¤ãƒˆ ã‚ªãƒ•ã‚»ãƒƒãƒˆã‚’æ¸›ç®—ã—ã¾ã™ã€‚
    // ldarg .0
    // ldarg .1
    // sizeof !!T
    // mul
    // sub
    // ret
SubtractByteOffset<T>(T, UIntPtr)	æŒ‡å®šã•ã‚ŒãŸãƒãƒãƒ¼ã‚¸ãƒ‰ ãƒã‚¤ãƒ³ã‚¿ãƒ¼ã‹ã‚‰ãƒã‚¤ãƒˆ ã‚ªãƒ•ã‚»ãƒƒãƒˆã‚’æ¸›ç®—ã—ã¾ã™ã€‚
    // ldarg .0
    // ldarg .1
    // sub
    // ret

// Unbox
Unbox<T>(Object)	ãƒœãƒƒã‚¯ã‚¹åŒ–ã•ã‚ŒãŸå€¤ã« mutable ref ã‚’è¿”ã—ã¾ã™ã€‚
    // ldarg .0
    // unbox !!T
    // ret

â– MemoryMarshal

- AsBytes
AsBytes<T>(ReadOnlySpan<T>)	1 ã¤ã®ãƒ—ãƒªãƒŸãƒ†ã‚£ãƒ–å‹ (T) ã® ReadOnlySpan<T> ã‚’ã€ReadOnlySpan<Byte> ã«ã‚­ãƒ£ã‚¹ãƒˆã—ã¾ã™ã€‚
AsBytes<T>(Span<T>)	1 ã¤ã®ãƒ—ãƒªãƒŸãƒ†ã‚£ãƒ–å‹ (T) ã® Span<T> ã‚’ã€Span<Byte> ã«ã‚­ãƒ£ã‚¹ãƒˆã—ã¾ã™ã€‚
AsMemory<T>(ReadOnlyMemory<T>)	ReadOnlyMemory<T> ã‹ã‚‰ Memory<T> ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’ä½œæˆã—ã¾ã™ã€‚
    return new Span<byte>(ref Unsafe.As<T, byte>(ref GetReference(span)), checked(span.Length * sizeof(T)));

- GetReference
GetReference<T>(Span<T>)	ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ 0 ã«ã‚ã‚‹ã‚¹ãƒ‘ãƒ³ã®è¦ç´ ã®å‚ç…§ã‚’è¿”ã—ã¾ã™ã€‚
GetReference<T>(ReadOnlySpan<T>)	ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ 0 ã«ã‚ã‚‹èª­ã¿å–ã‚Šå°‚ç”¨ã‚¹ãƒ‘ãƒ³ã®è¦ç´ ã®å‚ç…§ã‚’è¿”ã—ã¾ã™ã€‚
    ref span._reference;

- Cast
Cast<TFrom,TTo>(ReadOnlySpan<TFrom>)	1 ã¤ã®ãƒ—ãƒªãƒŸãƒ†ã‚£ãƒ–å‹ã®èª­ã¿å–ã‚Šå°‚ç”¨ã‚¹ãƒ‘ãƒ³ã‚’ã€åˆ¥ã®ãƒ—ãƒªãƒŸãƒ†ã‚£ãƒ–å‹ã®èª­ã¿å–ã‚Šå°‚ç”¨ã‚¹ãƒ‘ãƒ³ã«ã‚­ãƒ£ã‚¹ãƒˆã—ã¾ã™ã€‚
Cast<TFrom,TTo>(Span<TFrom>)	1 ã¤ã®ãƒ—ãƒªãƒŸãƒ†ã‚£ãƒ–å‹ã®ã‚¹ãƒ‘ãƒ³ã‚’ã€åˆ¥ã®ãƒ—ãƒªãƒŸãƒ†ã‚£ãƒ–å‹ã®ã‚¹ãƒ‘ãƒ³ã«ã‚­ãƒ£ã‚¹ãƒˆã—ã¾ã™ã€‚
    ...
    return new Span<TTo>(ref Unsafe.As<TFrom, TTo>(ref span._reference), toLength);

- CreateSpan
CreateSpan<T>(T, Int32)	å®šæœŸçš„ãªãƒãƒãƒ¼ã‚¸ãƒ‰ ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ä¸€éƒ¨ã«å¯¾ã™ã‚‹æ–°ã—ã„ã‚¹ãƒ‘ãƒ³ã‚’ä½œæˆã—ã¾ã™ã€‚
CreateReadOnlySpan<T>(T, Int32)	å®šæœŸçš„ãªãƒãƒãƒ¼ã‚¸ãƒ‰ ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ä¸€éƒ¨ã«å¯¾ã™ã‚‹æ–°ã—ã„èª­ã¿å–ã‚Šå°‚ç”¨ã‚¹ãƒ‘ãƒ³ã‚’ä½œæˆã—ã¾ã™ã€‚
    new Span<T>(ref Unsafe.AsRef(in reference), length)
CreateReadOnlySpanFromNullTerminated(Byte*)	null ã§çµ‚ã‚ã‚‹ãƒã‚¤ãƒˆ ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã®æ–°ã—ã„èª­ã¿å–ã‚Šå°‚ç”¨ã‚¹ãƒ‘ãƒ³ã‚’ä½œæˆã—ã¾ã™ã€‚
CreateReadOnlySpanFromNullTerminated(Char*)	null ã§çµ‚ã‚ã‚‹æ–‡å­—åˆ—ã®æ–°ã—ã„èª­ã¿å–ã‚Šå°‚ç”¨ã‚¹ãƒ‘ãƒ³ã‚’ä½œæˆã—ã¾ã™ã€‚

- TryGetArray
TryGetArray<T>(ReadOnlyMemory<T>, ArraySegment<T>)	åŸºã«ãªã‚‹ãƒ¡ãƒ¢ãƒª ãƒãƒƒãƒ•ã‚¡ãƒ¼ã‹ã‚‰é…åˆ—ã‚»ã‚°ãƒ¡ãƒ³ãƒˆã®å–å¾—ã‚’è©¦ã¿ã¾ã™ã€‚ æˆ»ã‚Šå€¤ã¯ã€æ“ä½œã®æˆåŠŸã‚’ç¤ºã—ã¾ã™ã€‚

- TryGetMemoryManager
TryGetMemoryManager<T,TManager>(ReadOnlyMemory<T>, TManager)	åŸºã«ãªã‚‹èª­ã¿å–ã‚Šå°‚ç”¨ãƒ¡ãƒ¢ãƒª ãƒãƒƒãƒ•ã‚¡ãƒ¼ã‹ã‚‰ MemoryManager<T> ã®å–å¾—ã‚’è©¦ã¿ã¾ã™ã€‚
TryGetMemoryManager<T,TManager>(ReadOnlyMemory<T>, TManager, Int32, Int32)	åŸºã«ãªã‚‹èª­ã¿å–ã‚Šå°‚ç”¨ãƒ¡ãƒ¢ãƒª ãƒãƒƒãƒ•ã‚¡ãƒ¼ã‹ã‚‰ã€MemoryManager<T>ã€é–‹å§‹ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã€é•·ã•ã®å–å¾—ã‚’è©¦ã¿ã¾ã™ã€‚

- ToEnumerable
ToEnumerable<T>(ReadOnlyMemory<T>)	æŒ‡å®šã—ãŸèª­ã¿å–ã‚Šå°‚ç”¨ãƒ¡ãƒ¢ãƒª ãƒãƒƒãƒ•ã‚¡ãƒ¼ã® IEnumerable<T> ãƒ“ãƒ¥ãƒ¼ã‚’ä½œæˆã—ã¾ã™ã€‚
    yieldã—ã¦ã„ã

- TryGetString
TryGetString(ReadOnlyMemory<Char>, String, Int32, Int32)	System.ReadOnlyMemory<Char> ã‹ã‚‰åŸºã«ãªã‚‹æ–‡å­—åˆ—ã®å–å¾—ã‚’è©¦ã¿ã¾ã™ã€‚

- Read
Read<T>(ReadOnlySpan<Byte>)	ãƒã‚¤ãƒˆã®èª­ã¿å–ã‚Šå°‚ç”¨ã‚¹ãƒ‘ãƒ³ã‹ã‚‰å‹ T ã®æ§‹é€ ä½“ã‚’èª­ã¿å–ã‚Šã¾ã™ã€‚
TryRead<T>(ReadOnlySpan<Byte>, T)	ãƒã‚¤ãƒˆå‹ã®èª­ã¿å–ã‚Šå°‚ç”¨ã‚¹ãƒ‘ãƒ³ã‹ã‚‰ T å‹ã®æ§‹é€ ä½“ã®èª­ã¿å–ã‚Šã‚’è©¦ã¿ã¾ã™ã€‚
    return Unsafe.ReadUnaligned<T>(ref GetReference(source));

- Write
Write<T>(Span<Byte>, T)	ãƒã‚¤ãƒˆå‹ã®ã‚¹ãƒ‘ãƒ³ã« T å‹ã®æ§‹é€ ä½“ã‚’æ›¸ãè¾¼ã¿ã¾ã™ã€‚
TryWrite<T>(Span<Byte>, T)	ãƒã‚¤ãƒˆå‹ã®ã‚¹ãƒ‘ãƒ³ã« T å‹ã®æ§‹é€ ä½“ã®æ›¸ãè¾¼ã¿ã‚’è©¦ã¿ã¾ã™ã€‚
    Unsafe.WriteUnaligned(ref GetReference(destination), value);

- AsRef
AsRef<T>(ReadOnlySpan<Byte>)	èª­ã¿å–ã‚Šå°‚ç”¨ã‚¹ãƒ‘ãƒ³ã®ãƒã‚¤ãƒˆã‚’ã€T å‹ã®æ§‹é€ ä½“ã¸ã®èª­ã¿å–ã‚Šå°‚ç”¨å‚ç…§ã¨ã—ã¦å†è§£é‡ˆã—ã¾ã™ã€‚
AsRef<T>(Span<Byte>)	ã‚¹ãƒ‘ãƒ³ã®ãƒã‚¤ãƒˆã‚’ã€T å‹ã®æ§‹é€ ä½“ã¸ã®å‚ç…§ã¨ã—ã¦å†è§£é‡ˆã—ã¾ã™ã€‚
    return ref Unsafe.As<byte, T>(ref GetReference(span));

- CreateFromPinnedArray
CreateFromPinnedArray<T>(T[], Int32, Int32)	start ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã§å§‹ã¾ã‚Š length å€‹ã®é …ç›®ã§æ§‹æˆã•ã‚Œã‚‹ã€äº‹å‰ã«ãƒ”ãƒ³ç•™ã‚ã•ã‚ŒãŸã‚¿ãƒ¼ã‚²ãƒƒãƒˆé…åˆ—ã®ä¸€éƒ¨ã«å¯¾ã™ã‚‹ã€æ–°ã—ã„ãƒ¡ãƒ¢ãƒª ãƒãƒƒãƒ•ã‚¡ãƒ¼ã‚’ä½œæˆã—ã¾ã™ã€‚

- GetArrayDataReference
GetArrayDataReference(Array)	array ã®ã‚¼ãƒ­ç•ªç›®ã®è¦ç´ ã¸ã®å‚ç…§ã‚’è¿”ã—ã¾ã™ã€‚ é…åˆ—ãŒç©ºã®å ´åˆã€ã‚¼ãƒ­ç•ªç›®ã®è¦ç´ ãŒæ ¼ç´ã•ã‚Œã‚‹å ´æ‰€ã¸ã®å‚ç…§ã‚’è¿”ã—ã¾ã™ã€‚ ãã®ã‚ˆã†ãªå‚ç…§ã¯ãƒ”ãƒ³ç•™ã‚ã«ä½¿ç”¨ã§ãã¾ã™ãŒã€é€†å‚ç…§ãŒç¦æ­¢ã•ã‚Œã¾ã™ã€‚
GetArrayDataReference<T>(T[])	array ã®ã‚¼ãƒ­ç•ªç›®ã®è¦ç´ ã¸ã®å‚ç…§ã‚’è¿”ã—ã¾ã™ã€‚ é…åˆ—ãŒç©ºã®å ´åˆã€ã‚¼ãƒ­ç•ªç›®ã®è¦ç´ ãŒæ ¼ç´ã•ã‚Œã‚‹å ´æ‰€ã¸ã®å‚ç…§ã‚’è¿”ã—ã¾ã™ã€‚ ãã®ã‚ˆã†ãªå‚ç…§ã¯ãƒ”ãƒ³ç•™ã‚ã«ä½¿ç”¨ã§ãã¾ã™ãŒã€é€†å‚ç…§ãŒç¦æ­¢ã•ã‚Œã¾ã™ã€‚
    return ref Unsafe.AddByteOffset(ref Unsafe.As<RawData>(array).Data, (nuint)RuntimeHelpers.GetMethodTable(array)->BaseSize - (nuint)(2 * sizeof(IntPtr)));




========================================================================================================
ğŸŸ©struct / readonly struct
========================================================================================================
D:\DevSmart\WorkSerializer\Serializer-bebop-master\Runtime\C#\Runtime\BebopReader.cs(14):     public ref struct BebopReader
D:\DevSmart\WorkSerializer\Serializer-bebop-master\Runtime\C#\Runtime\BebopWriter.cs(14):     public ref struct BebopWriter

Work\_Ref1\Get-LangExt\LanguageExt.Core\Immutable Collections\Seq\SeqLoan.cs(334):         public ref struct Enumerator
Work\_RefHW\BedrockFramework-main\src\Bedrock.Framework\Infrastructure2\BufferWriter.cs(10):     public ref struct BufferWriter<T> where T : IBufferWriter<byte>
Work\_RefHW\BedrockFramework-main\src\Bedrock.Framework.Experimental\Infrastructure2\BufferWriter.cs(10):     public ref struct BufferWriter<T> where T : IBufferWriter<byte>

DevSmart\WorkMvvm\WindowsCommunityToolkit-master\Microsoft.Toolkit.HighPerformance\_\Array2DColumnEnumerable{T}.cs(19):     public readonly ref struct Array2DColumnEnumerable<T>
...

DevSmart\_Reference\9.ILSpy\ICSharpCode.Decompiler.Tests\TestCases\Pretty\RefLocalsAndReturns.cs(53): 		public ref struct RefStruct
DevSmart\_Reference\9.ILSpy\ICSharpCode.Decompiler.Tests\TestCases\Pretty\RefLocalsAndReturns.cs(58): 		public readonly ref struct ReadOnlyRefStruct
DevSmart\_Reference\9.ILSpy\ICSharpCode.Decompiler.Tests\TestCases\Pretty\Using.cs(44): 		public ref struct UsingRefStruct

DevSmart\_Reference\BedrockFramework-master\src\Bedrock.Framework.Experimental\Infrastructure\BufferWriter.cs(10):     public ref struct BufferWriter<T> where T : IBufferWriter<byte>

DevSmart\_Reference\DevRoslyn\2Build\Hagar-master\src\Hagar\Buffers\Reader.cs(8):     public ref struct Reader
DevSmart\_Reference\DevRoslyn\2Build\Hagar-master\src\Hagar\Buffers\Writer.cs(8):     public ref struct Writer<TBufferWriter> where TBufferWriter : IBufferWriter<byte>

DevSmart\_Reference\NetFabric.Hyperlinq-main\NetFabric.Hyperlinq\Filtering\Where\Where.ReadOnlyMemory.cs(46):             public ref struct Enumerator
...

DevSourceGen\FixMeziantou.Analyzer\src\Meziantou.Analyzer\Internals\StringExtensions.cs(39):         public ref struct LineSplitEnumerator
DevSourceGen\FixMeziantou.Analyzer\src\Meziantou.Analyzer\Internals\StringExtensions.cs(85):         public readonly ref struct LineSplitEntry
DevSourceGen\FixMeziantou.Analyzer\tests\Meziantou.Analyzer.Test\Rules\MakeStructMemberReadOnlyAnalyzerTests.cs(580): internal ref struct PathReader

DevSourceGen\â– Roslyn\Hagar-master\src\Hagar\Buffers\Reader.cs(9):     public ref struct Reader
DevSourceGen\â– Roslyn\Hagar-master\src\Hagar\Buffers\Writer.cs(9):     public ref struct Writer<TBufferWriter> where TBufferWriter : IBufferWriter<byte>

Reference\AspNetCore\src\Shared\ServerInfrastructure\BufferWriter.cs(12):     internal ref struct BufferWriter<T> where T : IBufferWriter<byte>
Reference\Runtime\src\libraries\System.Memory\ref\System.Memory.cs(150):         public ref struct TryWriteInterpolatedStringHandler

DevSmart\WorkEvent\Mediator-main\src\Mediator\Messages\Unit.cs(6):     public readonly struct Unit : IEquatable<Unit>, IComparable<Unit>, IComparable

DevSmart\WorkMapper\FlatSharp-4.1.0\FlatSharp-4.1.0\src\FlatSharp.Runtime\IO\ArrayInputBuffer.cs(134):         private readonly struct Wrapper : IInputBuffer
...
DevSmart\WorkMvvm\Redux\ReduxSharp-master\examples\HelloWorld\Program.cs(41):     public readonly struct Increment { }
...
DevSmart\WorkMvvm\WindowsCommunityToolkit-master\Microsoft.Toolkit.HighPerformance\_\ParallelHelper.For.IAction.cs(196):         private readonly struct ActionInvoker<TAction>
...
DevSmart\WorkSerializer\Serializer-bebop-master\Core\Lexer\Tokenization\Models\Span.cs(15):     public readonly struct Span : IEquatable<Span>, IComparable<Span>
...
DevSmart\WorkSerializer\Serializer-SpanJson-master\SpanJson\Formatters\Dynamic\SpanJsonDynamicArray.cs(98):         private readonly struct Enumerable<TOutput> : IReadOnlyCollection<TOutput>, ICountableEnumerable
...

------
GitHub\Work-Net\Converter\Gen3Converter\Smart\Converter\Converters\EnumerableConverterFactory.Common.cs(45):         private readonly struct ArrayConvertList<TSource, TDestination> : IList<TDestination>
..
GitHub\Work-Net\Work\WorkBenchmarkMatchLoop\Program.cs(155):     private readonly StructEntry[] structEntries;
GitHub\Work-Net\WorkLinq\WorkLinq\Linq\Enumerable.Indexed.cs(40):         private readonly struct IndexedEnumerable<T> : IEnumerable<Indexed<T>>
GitHub\Work-Net\WorkLinq\WorkLinq\Linq\Indexed.cs(4):     public readonly struct Indexed<T>
GitHub\Work-Net-Data\Sandbox\ReaderBenchmark\TupleTest\ColumnInfo.cs(6):     public readonly struct ColumnInfo
GitHub\Work-Net-Data\Sandbox\WorkResultMapper\Smart.Data.Accessor\Data\Accessor\Engine\ColumnInfo.cs(6):     public readonly struct ColumnInfo
GitHub\Work-Net-Mapper\WorkEnumerableConverter\WorkEnumerableConverter.Tests\Data.cs(35):     public readonly struct MyListStruct<T> : IList<T>
GitHub\Work-Net-Mapper\WorkEnumerableConverter\WorkEnumerableConverter.Tests\Data.cs(77):     public readonly struct MyEnumerableStruct<T> : IEnumerable<T>
GitHub\Work-Net-Mapper\WorkMapper\Example\WorkContainerConvert\Program.cs(1643):     public readonly struct MyEnumerable<T> : IEnumerable<T>
GitHub\Work-Net-Mapper\WorkMapper\Example\WorkContainerConvert\StructConvert.cs(83):     public readonly struct EnumerableList : IList<int>
GitHubTemplate\template-blazor-server\Template.Server\Shared\Progress\ProgressStateScope.cs(4): public readonly struct ProgressStateScope : IDisposable
GitHubTemplate\template-wpf\Template.WindowsApp\Helpers\ExecuteScope.cs(4): public readonly struct ExecuteScope : IDisposable

----
Work\Extensions\Microsoft.Extensions.DependencyInjection\src\ServiceLookup\CallSiteChain.cs(76):         private readonly struct ChainItemInfo
Work\Extensions\Microsoft.Extensions.DependencyInjection\src\ServiceLookup\ServiceCacheKey.cs(9):     internal readonly struct ServiceCacheKey : IEquatable<ServiceCacheKey>
Work\Extensions\Microsoft.Extensions.DependencyInjection.Abstractions\src\AsyncServiceScope.cs(12):     public readonly struct AsyncServiceScope : IServiceScope, IAsyncDisposable
Work\Extensions\Microsoft.Extensions.Logging\src\LoggerInformation.cs(8):     internal readonly struct MessageLogger
Work\Extensions\Microsoft.Extensions.Logging\src\LoggerInformation.cs(45):     internal readonly struct ScopeLogger
Work\Extensions\Microsoft.Extensions.Logging\src\LoggerInformation.cs(67):     internal readonly struct LoggerInformation
Work\Extensions\Microsoft.Extensions.Logging.Abstractions\gen\LoggerMessageGenerator.Emitter.cs(141):         {nestedIndentation}private readonly struct __{lm.UniqueName}Struct : global::System.Collections.Generic.IReadOnlyList<global::System.Collections.Generic.KeyValuePair<string, object?>>
Work\Extensions\Microsoft.Extensions.Logging.Abstractions\src\EventId.cs(12):     public readonly struct EventId : IEquatable<EventId>
Work\Extensions\Microsoft.Extensions.Logging.Abstractions\src\FormattedLogValues.cs(16):     internal readonly struct FormattedLogValues : IReadOnlyList<KeyValuePair<string, object?>>
Work\Extensions\Microsoft.Extensions.Logging.Abstractions\src\LogEntry.cs(11):     public readonly struct LogEntry<TState>
Work\Extensions\Microsoft.Extensions.Primitives\src\StringSegment.cs(14):     public readonly struct StringSegment : IEquatable<StringSegment>, IEquatable<string?>
Work\Extensions\Microsoft.Extensions.Primitives\src\StringTokenizer.cs(13):     public readonly struct StringTokenizer :  IEnumerable<StringSegment>
Work\Extensions\Microsoft.Extensions.Primitives\src\StringValues.cs(17):     public readonly struct StringValues : IList<string?>, IReadOnlyList<string?>, IEquatable<StringValues>, IEquatable<string?>, IEquatable<string?[]?>

Work\_Ref1\Gen-ComToolkit\CommunityToolkit.HighPerformance\Streams\Sources\ArrayBufferWriterOwner.cs(15): internal readonly struct ArrayBufferWriterOwner : IBufferWriter<byte>
Work\_Ref1\Gen-ComToolkit\CommunityToolkit.HighPerformance\Streams\Sources\ArrayOwner.cs(16): internal readonly struct ArrayOwner : ISpanOwner
Work\_Ref1\Gen-ComToolkit\CommunityToolkit.HighPerformance\Streams\Sources\IBufferWriterOwner.cs(15): internal readonly struct IBufferWriterOwner : IBufferWriter<byte>
Work\_Ref1\Gen-ComToolkit\CommunityToolkit.HighPerformance\Streams\Sources\MemoryManagerOwner.cs(14): internal readonly struct MemoryManagerOwner : ISpanOwner
Work\_Ref1\Gen-ComToolkit\CommunityToolkit.Mvvm\Messaging\StrongReferenceMessenger.cs(813):     private readonly struct Recipient : IEquatable<Recipient>
Work\_Ref1\Gen-ComToolkit\CommunityToolkit.Mvvm\Messaging\Internals\Unit.cs(13): internal readonly struct Unit : IEquatable<Unit>
